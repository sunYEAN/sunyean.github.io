(function (window) {	/**	 * 计算加速度和两球距离的方法集合	 * @type {{get_wan(*, *): *, get_wan_a(*=, *=): *}}	 */	const UTIL = {		get_wan(b1, b2) {			const ball1 = b1.el;			const ball2 = b2.el;			const d_x = ball2.offsetLeft - ball1.offsetLeft - b1.options.r + b2.options.r;			const d_y = ball2.offsetTop - ball1.offsetTop - b1.options.r + b2.options.r;			const dis = Math.round( 100000 * Math.sqrt( d_x * d_x + d_y * d_y ) ) / 100000;			const angle = Math.abs( Math.atan( d_y / d_x ) * ( 180 / Math.PI ) );			return {				d_x,				d_y,				dis,				angle			};		},		get_wan_a(b1, b2) {			const {d_x, d_y, dis, angle} = this.get_wan( b1, b2 );			const a = Math.round( 100000 * G * b2.options.m / Math.pow( dis, 2 ) ) / 100000;			let ax = Math.round( 100000 * Math.cos( angle * Math.PI / 180 ) * a ) / 100000;			let ay = Math.round( 100000 * Math.sin( angle * Math.PI / 180 ) * a ) / 100000;			let xx = 1;			if ( d_x >= 0 ) {				if ( d_y < 0 ) {					xx = 2;					ay = -ay;				}			} else {				if ( d_y >= 0 ) {					xx = 4;					ax = -ax;				}				else {					xx = 3;					ax = -ax;					ay = -ay;				}			}			return {				xx,				a,				ax,				ay			};		}	};	/**	 * 常量	 * @type {number}	 */	const G = 9.8;	/**	 * 时间刻度	 * @type {number}	 */	const TimeLine = 100;	/**	 * 球体类	 * @param el	 * @param options	 * @returns {Ball}	 * @constructor	 */	function Ball(el, options) {		if ( this instanceof Ball ) {			this.options = Object.assign( {				m: 1000, // 质量 单位:KG				vx: 0, // X 方向初速度				vy: 0, // Y 方向初速度				r: 100 // 球体半径			}, options );			this.el = el;			this.time = Date.now();			this.timer = null;			this.count = 1;			this.init();		} else {			return new Ball( el, options );		}	}	Ball.prototype = {		init() {			const {vx, vy, r, x, y} = this.options;			this.el.style.cssText = `width: ${r * 2}px;height: ${r * 2}px;left:${x - r}px;top:${y - r}px`;			if ( !vx && !vy ) return;			setTimeout( this.animate(), 0 );		},		animate() {			const _this = this;			let t_level = Date.now();			cancelAnimationFrame( _this.timer );			if ( !_this.options.M || !_this.options.M.length ) {				// 匀速直线运动				function ani() {					const {vx, vy} = _this.options;					const time = ( Date.now() - _this.time ) / 3600;					const n_x = Math.round( vx * time * 100 ) / 100;					const n_y = Math.round( vy * time * 100 ) / 100;					_this.el.style.transform = `translate(${n_x}px, ${n_y}px)`;					if ( n_x > window.innerWidth || n_y > window.innerHeight ) {						cancelAnimationFrame( _this.timer );						return;					}					_this.timer = window.requestAnimationFrame( ani );				}				ani();			} else {				// 变速运动				function wan_animate() {					const {vx, vy} = _this.options;					const {ax, ay, xx} = UTIL.get_wan_a( _this, _this.options.M[0] );					const now = Date.now();					const t = Math.floor( 100000 * ( now - t_level ) / TimeLine ) / 100000;					const vx_a = Math.floor( 100000 * ( 2 * vx + ax * t ) / 2 ) / 100000;					const vy_a = Math.floor( 100000 * ( 2 * vy + ay * t ) / 2 ) / 100000;					t_level = now;					_this.options.vx = vx_a;					_this.options.vy = vy_a;					const s_x = _this.el.offsetLeft + vx_a * t;					const s_y = _this.el.offsetTop + vy_a * t;					// 计算当前时间的el应该在什么位置					_this.el.style.left = s_x + 'px';					_this.el.style.top = s_y + 'px';					// if (_this.count < 1000) {					// 	console.log(t);					// 	_this.count++;					// }					// if ( Math.abs( s_x ) >= window.innerWidth || Math.abs( s_y ) > window.innerHeight ) {					// 	cancelAnimationFrame( _this.timer );					// 	return;					// }					_this.timer = window.requestAnimationFrame( wan_animate );				}				wan_animate();			}		},		pause() {			cancelAnimationFrame( this.timer );		}	};	window.ClassBall = Ball;})(window);